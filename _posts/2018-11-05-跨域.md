---
layout:     post
title:      跨域
subtitle:   前端必备技能
date:       2018-11-05
author:     ARYAO
header-img: img/post/post-bg-cross-origin.jpg
catalog: true
tags:
    - 前端
---


##  为什么会出现跨域？

> “同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要**安全机制**。”

1. 同源策略（浏览器最基本的安全机制）

	简单地说，就是浏览器有一个出于安全方面的考虑的策略————同源策略，该策略不允许跨域调用其他页面的对象。

2. 跨域

	当**协议、域名（子域名+主域名）、端口号**中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。

	> 要注意：**跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了**。之所以会跨域，是因为受到了同源策略的限制，同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。

![](https://segmentfault.com/img/remote/1460000016756436)

## 什么是同源策略及其限制

同源策略的存在可以保护用户隐私信息，防止身份伪造等(读取Cookie)。

同源策略限制内容有：

1. Cookie、LocalStorage、IndexedDB 等存储性内容
1. DOM 节点
1. AJAX 请求不能发送

但是有三个标签是允许跨域加载资源：

1. `<img src=XXX>`
2. `<link href=XXX>`
3. `<script src=XXX>`

## 处理跨域方法

### JSONP
1. JSONP原理

	利用 `<script>` 元素的开放策略，网页可以得到从其他来源动态产生的 JSON 数据。

	> JSONP请求一定需要对方的服务器做支持才可以。

2. JSONP和AJAX对比

	- 相同点：都是客户端向服务端发送请求，从服务器端获取数据的方式。
	- 不同点：AJAX属于同源策略，JSONP属于非同源策略（跨域请求）
	
3. JSONP优缺点

	- 优点：兼容性好，可解决主流浏览器的跨域数据访问的问题。
	- 缺点：仅支持`get`方法，具有局限性。

4. JSONP的流程（以第三方API地址为例，不必考虑后台程序）

	- 声明一个回调函数(如`fn`)，作为参数值，传递给跨域请求数据的服务器。函数形参为要获取目标数据(服务器返回的data)。
	
    - 创建一个`<script>`标签，把跨域的API数据接口地址，赋值给`<script>`的src；同时，通过传参，向服务器传递该函数名（可以通过问号传参:`?callback=fn`）。

		- 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是fn，它准备好的数据是`fn([{"name":"jianshu"}]）`。
	- 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（fn），对返回的数据进行操作。
	
			<script type="text/javascript">
			    function fn(data) {
			        alert(data.msg);
			    }
			</script>
			<script type="text/javascript" src="http://crossdomain.com/jsonServerResponse?jsonp=fn"></script>

		其中 fn 是客户端注册的回调的函数,目的获取跨域服务器上的json数据后，对数据进行在处理。
		最后服务器返回给客户端数据的格式为:

			fn({ msg:'this is json data'})

5. jQuery的jsonp形式

	JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。

		$.ajax({
		url:"http://crossdomain.com/jsonServerResponse",
		dataType:"jsonp",
		type:"get",//可以省略
		jsonpCallback:"fn",//->自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略
		jsonp:"jsonp",//->把传递函数名的那个形参callback变为jsonp，可省略
		success:function (data){
		console.log(data);}
		});

### CORS

1. CORS原理
	整个CORS通信过程，都是浏览器自动完成，不需要用户参与。
	
	对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。
	
	浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

	因此，**实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信**。

2. CORS优缺点

	CORS要求浏览器(>IE10)和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成。
	
	- 优点在于功能更加强大支持各种HTTP Method
	- 缺点是兼容性不如JSONP。
	
	只需要在服务器端做一些小小的改造即可：

		header("Access-Control-Allow-Origin:*");
		header("Access-Control-Allow-Methods:POST,GET");
	> 例如：网站http://localhost:63342/ 页面要请求http://localhost:3000/users/userlist 页面，
	> userlist页面返回json字符串格`{name: 'Mr.Cao', gender: 'male', career: 'IT Education'}`
	
	> //在服务器端设置同源策略地址
	> 
	> 	
	> 	router.get("/userlist", function (req, res, next) {   
	> 	  var user = {name: 'Mr.Cao', gender: 'male', career: 'IT Education'};  
	> 	  res.writeHeader(200,{"Access-Control-Allow-Origin":'http://localhost:63342'});  
	> 	  res.write(JSON.stringify(user));  
	>     res.end();  
	> 	}); 

	在响应头上添加Access-Control-Allow-Origin属性，指定同源策略的地址。同源策略默认地址是网页的本身。
	只要浏览器检测到响应头带上了CORS，并且允许的源包括了本网站，那么就不会拦截请求响应。
![](https://image-static.segmentfault.com/274/667/2746673767-5bcd1e36dbfad)

### WebSocket

**Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。**

WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

	//前端代码：
	<div>user input：<input type="text"></div>
	<script src="./socket.io.js"></script>
	<script>
	var socket = io('http://www.domain2.com:8080');
	// 连接成功处理
	socket.on('connect', function() {
	    // 监听服务端消息
	    socket.on('message', function(msg) {
	        console.log('data from server: ---> ' + msg); 
	    });
	
	 // 监听服务端关闭
	    socket.on('disconnect', function() { 
	        console.log('Server socket has closed.'); 
	    });
	});
	document.getElementsByTagName('input')[0].onblur = function() {
	    socket.send(this.value);
	};
	</script>

	//====================分界线=============================

	//Nodejs socket后台：
	var http = require('http');
	var socket = require('socket.io');
	// 启http服务
	var server = http.createServer(function(req, res) {
	    res.writeHead(200, {
	        'Content-type': 'text/html'
	    });
	    res.end();
	});
	server.listen('8080');
	console.log('Server is running at port 8080...');
	// 监听socket连接
	socket.listen(server).on('connection', function(client) {
	    // 接收信息
	    client.on('message', function(msg) {
	        client.send('hello：' + msg);
	        console.log('data from client: ---> ' + msg);
	    });
	
	    // 断开处理
	    client.on('disconnect', function() {
	        console.log('Client socket has closed.'); 
	    });
	});

### postMessage
如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。

HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。

这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。

**postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即"协议 + 域名 + 端口"。**也可以设为*，表示不限制域名，向所有窗口发送。

> 接下来我们看个例子：
> 
> http://localhost:63342/index.html页面向http://localhost:3000/message.html传递“跨域请求信息”

	//发送信息页面 http://localhost:63342/index.html
	<html lang="en">  
	<head>  
	    <meta charset="UTF-8">  
	    <title>跨域请求</title>   
	</head>  
	<body>  
	    <iframe src="http://localhost:3000/users/reg" id="frm"></iframe>  
	    <input type="button" value="OK" onclick="run()">  
	</body>  
	</html>  
	<script>  
	   function  run(){  
	        var frm=document.getElementById("frm");  
	        frm.contentWindow.postMessage("跨域请求信息","http://localhost:3000");  
	   }  
	</script>  




	//接收信息页面 http://localhost:3000/message.html
	 window.addEventListener("message",function(e){  //通过监听message事件，可以监听对方发送的消息。
	  console.log(e.data);  
	},false);  